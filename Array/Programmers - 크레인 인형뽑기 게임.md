## **Programmers > 2019 카카오 개발자 겨울 인턴십 > 크레인 인형뽑기 게임**

</br>

[연습 문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64061)

</br>

:books: 내가 사용한 프로그래밍 언어 : Java  
:roller_coaster: 난이도 : Level 1

</br>

## 문제 요약

게임개발자 "죠르디"는 크레인 인형뽑기 기게를 모바일 게임으로 만들려고 한다.  
게임 화면은 N X N 크기의 정사각 격자이며 왼쪽에 크레인이 있고 오른쪽에는 바구니가 있다.  
모든 인형은 1 X 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있다.  
각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸이다.  
게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올려서 바구니에 담는다.  
바구니에는 가장 아래 칸부터 인형이 순서대로 쌓이게 된다.  
만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 된다.  
크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않는다.

</br>

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터뜨려져 사라진 인형의 개수를 return하도록 solution 함수를 완성하라.

</br>

## 추가 사항

- board 배열은 2차원 배열로 크기는 5 X 5 이상 30 X 30 이하
- board의 각 칸에는 0 이상 100 이하인 정수가 담겨있음
  - 0은 빈 칸을 나타냄
  - 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냄
- moves 배열의 크기는 1 이상 1,000 이하
- moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수

</br>

## 이해를 돕기 위한 추가 설명

### 입출력 예

|                             board                             |       moves       | result |
| :-----------------------------------------------------------: | :---------------: | :----: |
| [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] | [1,5,3,5,1,2,1,4] |   4    |

위 예시에 대한 그림은 다음과 같다.

</br>

(크레인 게임 예시 이미지 첨부)

</br>

나도 이 문제를 처음 봤을 때 이해가 잘 되지 않아서 추가로 설명을 적기로 했다.  
배열이 가로, 세로 어디로 어떻게 격자 모양으로 쌓이는지 잘 이해가 안 되었는데, 위의 입출력 예에서 board라는 배열 안의 첫 배열이 [0,0,0,0,0]이라는 것을 보고 힌트를 얻었다.  
위에서부터 아래로 만들어나간다고 생각하면 편하다.  
크레인을 작동시키기 전에 예시에서 주어진 board를 격자 모양으로 표현하자면 다음과 같다.

| 1번 칸 | 2번 칸 | 3번 칸 | 4번 칸 | 5번 칸 |
| :----: | :----: | :----: | :----: | :----: |
|   0    |   0    |   0    |   0    |   0    |
|   0    |   0    |   1    |   0    |   3    |
|   0    |   2    |   5    |   0    |   1    |
|   4    |   2    |   4    |   4    |   2    |
|   3    |   5    |   1    |   3    |   1    |

이후 주어진 moves라는 배열, [1,5,3,5,1,2,1,4]를 순서대로 뽑아보면 다음과 같은 숫자들이 뽑힌다.

```
4, 3, 1, 1, 3, 2, 4
```

이 때 중간중간에 겹치는 숫자들을 제거하는 코드를 작성한다면 겹치는 "1"을 제거하고, "1을" 제거하면 "3"이 겹치게 되니 "3"도 제거해서

```
4, 2, 4
```

이런 결과가 나온다.  
위에 첨부한 이미지와 똑같은 결과임을 확인할 수 있다.

</br>

## 풀이

처음에 이 문제를 접하고, 2차원 배열을 어떻게 활용해서 격자를 만든다는건지 이해를 못하겠어서 '질문하기' 탭을 눌러보았다.  
눌러보니 문제 자체에 대한 질문보다는 본인이 제시한 코드가 테스트 몇 번을 통과하지 못해서 한 번 봐달라는 식의 내용들이 많았다.  
무심결에 그 중 하나의 코드를 읽어보게 되었는데, 그것을 확인하고 문제 풀이의 가닥을 잡았다.

```java
import java.util.Stack;

class Solution {
    public int solution(int[][] board, int[] moves) {
        int answer = 0;
        Stack<Integer> bucket = new Stack<>();
        bucket.push(0);

        for (int move : moves) {
            int line = move - 1;
            for (int j = 0; j < board.length; j++) {
                if (board[j][line] != 0) {
                    if (bucket.peek() == board[j][line]) {
                        bucket.pop();
                        answer += 2;
                    } else {
                        bucket.push(board[j][line]);
                    }
                    board[j][line] = 0;
                    break;
                }
            }
        }
        return answer;
    }
}
```

Stack이라는 것을 처음으로 써보았다.  
이 Stack이라는 것에 대해 아직은 잘 이해가 되진 않았지만, 배열이나 ArrayList와 매우 흡사했으며, 배열의 길이를 정해주거나 할 필요가 없이 편리하게 사용 가능하다는 점을 확인할 수 있었다.  
Stack에 관한 내용들은 나중에 따로 공부해서 정리하도록 해야겠다.

</br>

아무튼 처음에 지나치게 난해하게 생각했던 것과는 달리 풀이는 그렇게까지 복잡하지 않게 나왔다.  
간단하게 설명하자면, 주어진 크레인 이동 횟수인 moves만큼 for문을 돌리면서, 그 안에서 다시 board 배열의 move - 1 인덱스의 값이 0이 아닌 것을 뽑는다.  
뽑은 것이 0이 아니라는 조건에서 바로 기존에 선언해둔 Stack과 비교해가면서, 만약 Stack의 최근 값과 같다면 Stack을 지우고 현재값을 포함해서 2개가 지워졌으니 결과값에 2를 추가한다.  
그리고 Stack에서 뽑은 값과 같지 않은 경우에는 그 값을 Stack에 추가해준다.  
이후 Stack과 뽑은 값이 같던 같지 않았던, 뽑은 값에 0을 할당해주고 break를 걸어주는 것이다.  
break는 뽑은 값이 0이 아니라면 연산을 해주고 바로 다음 바깥쪽 for문을 계속 돌릴 수 있게 해준다.
